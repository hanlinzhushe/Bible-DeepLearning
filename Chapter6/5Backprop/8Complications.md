> **[success]**  
反向传播算法的实际使用还要考虑其它问题。  
简单使用可以调库，DL库已经将这些问题处理好。  
当面对复杂情况需要自己实现反向传播算法或其中一部分时，会对本节内容有一些感触。  
（1）反向传播计算偏导的同时，顺便计算一些别的结果  
（2）内存问题  
（3）操作数据的类型  
（4）处理未定义梯度的操作  
可以阅读主要DL框架看看别人是怎么做的。  


我们这里描述的反向传播算法要比实践中实际使用的实现要简单。

正如前面提到的，我们将操作的定义限制为返回单个张量的函数。
大多数软件实现需要支持可以返回多个张量的操作。 
例如，如果我们希望计算张量中的最大值和该值的索引，则最好在单次运算中计算两者，因此将该过程实现为具有两个输出的操作效率更高。

我们还没有描述如何控制反向传播的内存消耗。
反向传播经常涉及将许多张量加在一起。
在朴素方法中，将分别计算这些张量中的每一个，然后在第二步中对所有这些张量求和。 
朴素方法具有过高的存储瓶颈，可以通过保持一个缓冲器，并且在计算时将每个值加到该缓冲器中来避免该瓶颈。

反向传播的现实实现还需要处理各种数据类型，例如32位浮点数、64位浮点数和整型。
处理这些类型的策略需要特别的设计考虑。

一些操作具有未定义的梯度，重要的是跟踪这种情况并且确定用户请求的梯度是否是未定义的。

各种其他技术的特性使现实世界的微分更加复杂。 这些技术性并不是不可逾越的，本章已经描述了计算微分所需的关键知识工具，但重要的是要知道还有许多的精妙之处存在。