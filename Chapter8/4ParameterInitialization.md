有些优化算法本质上是非迭代的，只是求解一个解点。
有些其它优化算法本质上是迭代的，但是应用于这一类的优化问题时，能在可接受的时间内收敛到可接受的解，并且与初始值无关。
深度学习训练算法通常没有这两种奢侈的性质。
深度学习模型的训练算法通常是迭代的，因此要求使用者指定一些开始迭代的初始点。
此外，训练深度模型是一个足够困难的问题，以致于大多数算法都很大程度地受到初始化选择的影响。
初始点能够决定算法是否收敛，有些初始点十分不稳定，使得该算法会遭遇数值困难，并完全失败。
当学习收敛时，初始点可以决定学习收敛得多快，以及是否收敛到一个代价高或低的点。
此外，差不多代价的点可以具有区别极大的泛化误差，初始点也可以影响泛化。

> **[success]**  
初始化对于深度学习很重要，因为它能决定：  
(1) 是否收敛  
(2) 是否稳定  
(3) 收敛到哪个点  

现代的初始化策略是简单的、启发式的。
设定改进的初始化策略是一项困难的任务，因为神经网络优化至今还未被很好地理解。
大多数初始化策略基于在神经网络初始化时实现一些很好的性质。
然而，我们并没有很好地理解这些性质中的哪些会在学习开始进行后的哪些情况下得以保持。
进一步的难点是，有些初始点从优化的观点看或许是有利的，但是从泛化的观点看是不利的。
我们对于初始点如何影响泛化的理解更是相当原始的，几乎没有提供如何选择初始点的任何指导。

> **[success]**  
改进初始化参数的困难：  
(1) 在初始化化时的好性质如何保持下去  
(2) 看似对训练有利的初始化实际上对泛化不利  

# w的初始化

> **[success]**  
(1) 输出和输入一样多，可以使用Gram-Schmidt正交化于初始的权重矩阵。  
(2) 在高维空间上使用高熵分布来随机初始化。  
(3) 为高斯或均匀分布中随机抽取的值。  
(4) 更大的初始权重具有更强的破坏对称性的作用。  
(5) 正则化的角度希望使用较小的参数。  
(6) 标准初始化  
(7) 初始化为随机正交矩阵  
(8) 将每层权重的初始数值范围设为超参数，使超参数搜索算法挑选这些数值范围。  

## 基于参数的差异性设计初始化算法  、

也许完全确知的唯一特性是**初始参数需要在不同单元间"破坏对称性"**。
如果具有相同激活函数的两个隐藏单元连接到相同的输入，那么这些单元必须具有不同的初始参数。
如果它们具有相同的初始参数，然后应用到确定性损失和模型的确定性学习算法将一直以相同的方式更新这两个单元。
即使模型或训练算法能够使用随机性为不同的单元计算不同的更新（例如使用\,Dropout的训练），通常来说，最好还是初始化每个单元使其和其他单元计算不同的函数。
这或许有助于确保没有输入模式丢失在前向传播的零空间中，以及没有梯度模式丢失在反向传播的零空间中。
每个单元计算不同函数的目标促使了参数的随机初始化。
我们可以明确地搜索一大组彼此互不相同的基函数，但这经常会导致明显的计算代价。  
例如，如果我们有和输出一样多的输入，我们可以使用Gram-Schmidt正交化于初始的权重矩阵，保证每个单元计算彼此非常不同的函数。  
> **[warning]** Gram-Schmidt正交化?  

与之相比，在高维空间上使用高熵分布来随机初始化，计算代价更小并且不太可能分配单元计算彼此相同的函数。
> **[warning]** 高熵分布?  

通常情况下，我们可以为每个单元的偏置设置启发式挑选的常数，仅随机初始化权重。
额外的参数（例如用于编码预测条件方差的参数）通常和偏置一样设置为启发式选择的常数。
> **[warning]** 用于编码预测条件方差的参数?  

## 基于参数的大小设计初始化算法

我们几乎总是初始化模型的权重为高斯或均匀分布中随机抽取的值。
高斯或均匀分布的选择似乎不会有很大的差别，但也没有被详尽地研究。
然而，初始分布的大小确实对优化过程的结果和网络泛化能力都有很大的影响。

更大的初始权重具有更强的破坏对称性的作用，有助于避免冗余的单元。
它们也有助于避免在每层线性成分的前向或反向传播中丢失信号——矩阵中更大的值在矩阵乘法中有更大的输出。
如果初始权重太大，那么会在前向传播或反向传播中产生爆炸的值。
在循环网络中，很大的权重也可能导致混沌（对于输入中很小的扰动非常敏感，导致确定性前向传播过程表现随机）。
在一定程度上，梯度爆炸问题可以通过梯度截断来缓解（执行梯度下降步骤之前设置梯度的阈值）。
较大的权重也会产生使得激活函数饱和的值，导致饱和单元的梯度完全丢失。
这些竞争因素决定了权重的理想初始大小。

关于如何初始化网络，正则化和优化有着非常不同的观点。
**优化观点建议权重应该足够大以成功传播信息，但是正则化希望其小一点。**
诸如随机梯度下降这类对权重较小的增量更新，趋于停止在更靠近初始参数的区域（不管是由于卡在低梯度的区域，还是由于触发了基于过拟合 的提前终止准则）的优化算法倾向于最终参数应接近于初始参数。
回顾\sec?，在某些模型上，提前终止的梯度下降等价于权重衰减。
在一般情况下，提前终止的梯度下降和权重衰减不同，但是提供了一个宽松的类比去考虑初始化的影响。
我们可以将初始化参数$\theta$为$\theta_0$类比于强置均值为$\theta_0$的高斯先验$p(\theta)$。
从这个角度来看，选择$\theta_0$接近$0$是有道理的。
这个先验表明，单元间彼此互不交互比交互更有可能。
只有在目标函数的似然项表达出对交互很强的偏好时，单元才会交互。  
> **[warning]** ?

另一方面，如果我们初始化$\theta_0$为很大的值，那么我们的先验指定了哪些单元应互相交互，以及它们应如何交互。


有些启发式方法可用于选择权重的初始大小。
一种初始化$m$个输入和$n$输出的全连接层的权重的启发式方法是从分布$U(-\frac{1}{\sqrt{m}}, \frac{1}{\sqrt{m}})$中采样权重，
而~{GlorotAISTATS2010-small}建议使用标准初始化, % ?
$$
\begin{aligned}
    W_{i,j} \sim U \left(-\sqrt{\frac{6}{m+n}}, \sqrt{\frac{6}{m+n}}\right) .
\end{aligned}
$$

后一种启发式方法初始化所有的层，折衷于使其具有相同激活方差和使其具有相同梯度方差之间。
这假设网络是不含非线性的链式矩阵乘法，据此推导得出。
现实的神经网络显然会违反这个假设，但很多设计于线性模型的策略在其非线性对应中的效果也不错。

## 基于权重因子的初始化策略

{Saxe-et-al-ICLR13}推荐初始化为随机正交矩阵，仔细挑选负责每一层非线性缩放或者说\,\textbf{增益}(gain)因子$g$。  
> **[warning]**  
缩放因子？增益因子？  

他们得到了用于不同类型的非线性激活函数的特定缩放因子。
这种初始化方案也是启发于不含非线性的矩阵相乘序列的深度网络。
在该模型下，这个初始化方案保证了达到收敛所需的训练迭代总数独立于深度。


增加缩放因子$g$将网络推向网络前向传播时激活范数增加，反向传播时梯度范数增加的区域。
{Sussillo14}表明，正确设置缩放因子足以训练深达$1000$层的网络，而不需要使用正交初始化。
这种方法的一个重要观点是，在前馈网络中，激活和梯度会在每一步前向传播或反向传播中增加或缩小，遵循随机游走行为。
这是因为前馈网络在每一层使用了不同的权重矩阵。
如果该随机游走调整到保持范数，那么前馈网络能够很大程度地避免相同权重矩阵用于每层的梯度消失与爆炸问题，如\sec?所述。
> **[warning]**  ？  

## 权重初始化算法的局限性  

可惜，这些初始权重的最佳准则往往不会带来最佳效果。
这可能有三种不同的原因。
首先，我们可能使用了错误的标准——它实际上并不利于保持整个网络信号的范数。
其次，初始化时强加的性质可能在学习开始进行后不能保持。
最后，该标准可能成功提高了优化速度，但意外地增大了泛化误差。
在实践中，我们通常需要将权重范围视为超参数，其最优值大致接近，但并不完全等于理论预测。

## 参数的初始化数值范围

数值范围准则的一个缺点是，设置所有的初始权重具有相同的标准差，例如$\frac{1}{\sqrt{m}}$，会使得层很大时每个单一权重会变得极其小。
{martens2010hessian-small}提出了一种被称为稀疏初始化的替代方案，每个单元初始化为恰好有$k$个非零权重。
这个想法保持该单元输入的总数量独立于输入数目$m$，而不使单一权重元素的大小随$m$缩小。
稀疏初始化有助于实现单元之间在初始化时更具多样性。
但是，获得较大取值的权重也同时被加了很强的先验。  
> **[warning]**  怎样的先验？  

因为梯度下降需要很长时间缩小"不正确"的大值，这个初始化方案可能会导致某些单元出问题，例如\,maxout\,单元有几个过滤器，互相之间必须仔细调整。

计算资源允许的话，将每层权重的初始数值范围设为超参数通常是个好主意，使用\sec?介绍的超参数搜索算法，如随机搜索，挑选这些数值范围。
是否选择使用密集或稀疏初始化也可以设为一个超参数。
作为替代，我们可以手动搜索最优初始范围。
一个好的挑选初始数值范围的经验法则是观测单个小批量数据上的激活或梯度的幅度或标准差。
如果权重太小，那么当激活值在小批量上前向传播于网络时，激活值的幅度会缩小。
通过重复识别具有小得不可接受的激活值的第一层，并提高其权重，最终有可能得到一个初始激活全部合理的网络。
如果学习在这点上仍然很慢，观测梯度的幅度或标准差可能也会有所帮助。
这个过程原则上是自动的，且通常计算量低于基于验证集误差的超参数优化，因为它是基于初始模型在单批数据上的行为反馈，而不是在验证集上训练模型的反馈。
由于这个协议很长时间都被启发式使用，最近~{mishkin2015all}更正式地研究了该协议。

目前为止，我们关注在权重的初始化上。
幸运的是，其他参数的初始化通常更容易。

# 偏置的初始化

> **[success]**  
(1) 使用启发式挑选的初值  
(2) 必须和设置权重的方法协调。  
(3) 设置为0在大多数方案中是可行的。  
(4) 输出单元的b应正确设置。  
(5) 对于一些特殊的unit，合理设置b以避免unit饱和。  
(6) 一个单元通过b控制其他单元能否参与到等式中。


设置偏置的方法必须和设置权重的方法协调。
设置偏置为零通常在大多数权重初始化方案中是可行的。
存在一些我们可能设置偏置为非零值的情况：

## 偏导非0的情况

+ 如果偏置是作为输出单元，那么初始化偏置以获取正确的输出边缘统计通常是有利的。
要做到这一点，我们假设初始权重足够小，该单元的输出仅由偏置决定。
这说明设置偏置为应用于训练集上输出边缘统计的激活函数的逆。
例如，如果输出是类上的分布，且该分布是高度偏态分布，第$i$类的边缘概率由某个向量$c$的第$i$个元素给定，那么我们可以通过求解方程$\text{softmax}(b)=c$来设置偏置向量$b$。
这不仅适用于分类器，也适用于我们将在第三部分遇到的模型，例如自编码器和玻尔兹曼机。
这些模型拥有输出类似于输入数据$x$的网络层，初始化这些层的偏置以匹配$x$上的边缘分布将有助于模型学习。
> **[warning]** ？  

+ 有时，我们可能想要选择偏置以避免初始化引起太大饱和。
例如，我们可能会将ReLU的隐藏单元设为$0.1$而非$0$，以避免ReLU在初始化时饱和。
尽管这种方法违背不希望偏置具有很强输入的权重初始化准则。
例如，不建议使用随机游走初始化{cite?}。
> **[warning]** 随机游走初始化？  

+ 有时，一个单元会控制其他单元能否参与到等式中。
在这种情况下，我们有一个单元输出$u$，另一个单元$h\in[0,1]$，那么我们可以将$h$视作门，以决定$uh\approx 1$还是$uh\approx 0$。
在这种情形下，我们希望设置偏置 $h$，使得在初始化的大多数情况下$h\approx 1$。
否则，$u$没有机会学习。
例如，{Jozefowicz-et-al-ICML2015}提议设置~LSTM~模型遗忘门的偏置为$1$，如\sec?所述。

# 方差或精确度参数的初始化

另一种常见类型的参数是方差或精确度参数。  
> **[success]** 精确度参数，例如$\epsilon$  

例如，我们用以下模型进行带条件方差估计的线性回归
$$
\begin{aligned}
    p(y\mid x) = \mathcal{N} (y \mid w^\top x + b, 1/\beta) ,
\end{aligned}
$$
其中$\beta$是精确度参数。
通常我们能安全地初始化方差或精确度参数为$1$。
另一种方法假设初始权重足够接近零，设置偏置可以忽略权重的影响，然后设定偏置以产生输出的正确边缘均值，并将方差参数设置为训练集输出的边缘方差。

# 使用机器学习训练出参数

除了这些初始化模型参数的简单常数或随机方法，还有可能使用机器学习初始化模型参数。
在本书第三部分讨论的一个常用策略是使用相同的输入数据集，用无监督模型训练出来的参数来初始化监督模型。
我们也可以在相关问题上使用监督训练。
即使是在一个不相关的任务上运行监督训练，有时也能得到一个比随机初始化具有更快收敛率的初始值。
这些初始化策略有些能够得到更快的收敛率和更好的泛化误差，原因在于它们编码了模型初始参数的分布信息。
其他一些策略表现出效果不错的原因则主要在于它们设置参数为正确的数值范围，或是设置不同单元计算互相不同的函数。
